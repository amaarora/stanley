"""Template definitions for code generation."""

from pathlib import Path

from jinja2 import Environment, FileSystemLoader, Template
from stanley_codegen.exceptions import TemplateError


class TemplateManager:
    """Manage code generation templates."""

    def __init__(self, template_dir: Path | None = None):
        """Initialize template manager."""
        if template_dir:
            self.env = Environment(loader=FileSystemLoader(template_dir))
        else:
            # Use built-in templates
            self.env = Environment()
            self._register_default_templates()

    def _register_default_templates(self):
        """Register default templates."""
        self.env.globals["TOOL_TEMPLATE"] = TOOL_TEMPLATE
        self.env.globals["AGENT_TEMPLATE"] = AGENT_TEMPLATE
        self.env.globals["INIT_TEMPLATE"] = INIT_TEMPLATE
        self.env.globals["README_TEMPLATE"] = README_TEMPLATE

    def get_template(self, name: str) -> Template:
        """Get a template by name."""
        if name in self.env.globals:
            return self.env.from_string(self.env.globals[name])

        try:
            return self.env.get_template(name)
        except Exception as e:
            raise TemplateError(f"Template '{name}' not found: {e}")

    def render(self, template_name: str, **context) -> str:
        """Render a template with context."""
        template = self.get_template(template_name)
        return template.render(**context)


# Default Templates

TOOL_TEMPLATE = '''"""{{ tool.generated_description|capitalize }} tool."""

from typing import Annotated

from stanley.base_tool import Tool


class {{ tool.class_name }}(Tool):
    """{{ tool.generated_description|capitalize }}."""

    name = "{{ tool.name.lower() }}"
    description = "{{ tool.generated_description|capitalize }}"
    def execute(
        self,
        {%- for param in tool.parameters %}
        {{ param.name }}: Annotated[
            {{ param.type.value }},
            "{{ param.description or param.name + ' parameter' }}",
        ]
        {%- if not param.required %} = {{ param.default|repr }}{% endif %}
        {%- if not loop.last %},{% endif %}
        {%- endfor %}
    ) -> dict:
        """{{ tool.generated_description|capitalize }}."""
        # TODO: Implement {{ tool.name }} functionality
        return {
            "status": "success",
            "tool": "{{ tool.name }}",
            "message": f"Processed {{ tool.name }} request",
            {% if tool.parameters -%}
            "parameters": {
                {%- for param in tool.parameters %}
                "{{ param.name }}": {{ param.name }},
                {%- endfor %}
            },
            {%- endif %}
            "data": {},  # Add actual implementation here
        }
'''

AGENT_TEMPLATE = '''"""{{ agent_name }} - Generated by Stanley Codegen."""

import logging
from pathlib import Path

from dotenv import load_dotenv

from stanley import Agent
from stanley.tools import AgentEndTaskTool
{%- for tool in tools %}
from tools.{{ tool.name.lower() }} import {{ tool.class_name }}
{%- endfor %}

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def load_system_prompt() -> str:
    """Load system prompt from file."""
    prompt_file = Path(__file__).parent / "{{ system_prompt_file.name }}"
    if not prompt_file.exists():
        logger.warning(f"System prompt file not found: {prompt_file}")
        return "You are a helpful AI assistant."

    with open(prompt_file) as f:
        return f.read().strip()


def create_agent() -> Agent:
    """Create and configure the agent."""
    system_prompt = load_system_prompt()

    tools = [
        {%- for tool in tools %}
        {{ tool.class_name }}(),
        {%- endfor %}
        AgentEndTaskTool(),
    ]

    agent = Agent(
        model="{{ model }}",
        tools=tools,
        system_prompt=system_prompt,
    )

    logger.info(f"Created agent with {len(tools)} tools")
    return agent


def main():
    """Main entry point."""
    try:
        agent = create_agent()

        query = "Hello! Please help me with my task."
        logger.info(f"Running agent with query: {query}")

        response = agent.run(query, stream=True)

        for chunk in response:
            print(chunk, end="", flush=True)
        print()
    except KeyboardInterrupt:
        logger.info("Agent interrupted by user")
    except Exception as e:
        logger.error(f"Agent error: {e}", exc_info=True)
        raise


if __name__ == "__main__":
    main()
'''

INIT_TEMPLATE = '''"""Tools package for {{ agent_name }}."""

{%- for tool in tools %}
from tools.{{ tool.name.lower() }} import {{ tool.class_name }}
{%- endfor %}

__all__ = [
    {%- for tool in tools %}
    "{{ tool.class_name }}",
    {%- endfor %}
]
'''

README_TEMPLATE = """# {{ agent_name }}

Generated by Stanley Codegen.

## Tools

This agent includes the following tools:

{%- for tool in tools %}
- **{{ tool.name }}**: {{ tool.generated_description|capitalize }}
{%- endfor %}

## Usage

```bash
# Install dependencies
pip install stanley-ai python-dotenv

# Set up environment variables
cp .env.example .env
# Edit .env with your API keys

# Run the agent
python agent.py
```

## Configuration

Edit `system_prompt.txt` to customize the agent's behavior.

## Development

To regenerate this agent:

```bash
stanley-codegen generate tools.yml
```
"""
